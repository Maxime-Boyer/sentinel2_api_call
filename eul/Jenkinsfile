#!/usr/bin/env groovy

// Version templatefile python : 2.0.5

// D√©claration de la shared library build_libs
@Library('build_libs') _

// Options du build. Plusieurs sont d√©finies via la m√©thode defaultBuildOptions.
// Consulter le README du template pour plus d'informations
Map options = [
    // Nombre de builds √† conserver dans l'historique des builds du job Jenkins
    NUM_TO_KEEP: 10,
    // La branche par d√©faut √† partir de laquelle la publication Artifactory et l'analyse SonarQube doivent √™tre faits
    BRANCH_DEVELOP: 'feat/refactor_eul',
    // Version de Python
    PYTHON_VERSION: '3.9',
    // Indique si une image Docker applicative est √† produire par le pipeline pour le projet
    DOCKER_BUILD: true,
    // Permet d'activer des logs plus d√©taill√©s lors du build Docker
    IMAGE_BUILD_VERBOSE: false,
]

// Valorisation des options par d√©faut
options = defaultBuildOptions(options)

// Propri√©t√©s du job
properties([
    // Connexion GitLab
    gitLabConnection("${options['GITLAB_NAME']}"),
    // Conservation des N derni√®res ex√©cutions
    buildDiscarder(logRotator(numToKeepStr: "${options['NUM_TO_KEEP']}")),
    // D√©clenchement du job via webhook lors de push de nouveau code ou de cr√©ation de merge request
    pipelineTriggers([[$class: 'GitLabPushTrigger', triggerOnPush: true, triggerOnMergeRequest: true, branchFilterType: 'All']])
])

// L'analyse qualit√© et la publication des artefacts sont lanc√©es uniquement sur la branche de d√©veloppement
Boolean qualityAnalysisEnabled = env.BRANCH_NAME == options['BRANCH_DEVELOP']
Boolean publishEnabled = env.BRANCH_NAME == options['BRANCH_DEVELOP']
Boolean dockerEnabled = env.BRANCH_NAME == options['BRANCH_DEVELOP'] && options['DOCKER_BUILD'] == true

// Sinon l'horodatage des logs eul-cli, s'il est activ√©, est d√©cal√© d'une heure
env.TZ = 'Europe/Paris'

// Horodatage des lignes de log Jenkins
timestamps {
    // Prise en charge des codes ANSI pour affichage de logs Jenkins coloris√©s
    ansiColor('xterm') {
        withTools([
            [name: 'python', version: "${options['PYTHON_VERSION']}"],
            [name: 'sonar-scanner', version: 'latest', registry: 'eul'],
            dockerEnabled ? [name: 'buildkit', image: 'moby/buildkit', version: 'v0.10.3-rootless'] : [:],
        ]) {
            try {
                stage('Checkout') {
                    println 'üî∞ R√©cup√©ration du code source'
                    scmInfo = checkout scm
                    env.GIT_URL = scmInfo.GIT_URL
                    env.GIT_SHORT_URL = "${env.GIT_URL}".replace('https://', '')
                    env.GIT_COMMIT = scmInfo.GIT_COMMIT
                    env.LIMIT_HOSTS = sh(script: 'git show -s --pretty=%an', returnStdout: true).trim()
                    skipPipeline = sh(script: "git log -1 | grep '\\[ci-skip\\]'", returnStatus: true)
                    println '‚úîÔ∏è R√©cup√©ration du code source effectu√©e'
                }
                if (skipPipeline == 0) {
                    skipReason = sh(script: 'git log -1 --pretty=oneline', returnStdout: true)
                    println "üìú Build ignor√©. Le dernier commit contient [ci-skip] : ${skipReason}"
                    currentBuild.displayName = 'Build skipped because of [ci-skip] tag'
                    // Arr√™t du pipeline de build
                    currentBuild.result = 'SUCCESS'
                    return
                }
                stage('Setup') {
                    container('python') {
                        println 'üî∞ Configuration du build'
                        // Extraction de la version
                        env.VERSION = sh(returnStdout: true, script: 'eul python setup.py --version').trim()
                        env.PIP_PACKAGE_NAME = sh(returnStdout: true, script: 'eul python setup.py --name').trim()
                        currentBuild.displayName = env.VERSION
                        println '‚úîÔ∏èÔ∏è Configuration du build effectu√©e'
                    }
                }
                stage('Install') {
                    container('python') {
                        gitlabCommitStatus('install') {
                            println 'üî∞ Installation des modules'
                            sh 'eul pip install --upgrade pip'
                            sh 'eul pip install -r requirements.txt --upgrade --no-cache-dir .[ci]'
                            println '‚úîÔ∏èÔ∏è Installation des modules effectu√©e'
                        }
                    }
                }
                stage('Tests') {
                    container('python') {
                        gitlabCommitStatus('tests') {
                            println 'üî∞ Ex√©cution des tests unitaires'
                            if (sh(script: 'pytest -m \'not database_access\' ', returnStatus: true)) {
                                unstable '‚ö†Ô∏èÔ∏è Les tests unitaires ont √©chou√©'
                            }
                            println '‚úîÔ∏èÔ∏è Ex√©cution des tests unitaires effectu√©e'
                        }
                    }
                }
                stage('QA') {
                    when(qualityAnalysisEnabled) {
                        println 'üî∞ Analyse qualit√©'
                        gitlabCommitStatus('formatage') {
                            container('python') {
                                if (sh(script: 'black --check --diff .', returnStatus: true)) {
                                    error '‚ùå Black a identifi√© un formatage de code incorrect'
                                }
                                println '‚úîÔ∏èÔ∏è V√©rification avec le formateur de code Black effectu√©'
                            }
                        }
                        gitlabCommitStatus('sonarqube') {
                            container('python') {
                                sh "pylint src > pylint-report.txt || pylint-exit \$?"
                                println '‚úîÔ∏èÔ∏è Analyse statique avec pylint effectu√©e'
                            }
                            container('sonar-scanner') {
                                withSonarQubeEnv('sonarqube') {
                                    // Le nom de la branche est ajout√© √† la fin du nom du projet SonarQube
                                    String sonarBranch = env.BRANCH_NAME?.replaceAll(/[\\]/, '_').replaceAll(/[, ]/, '')
                                    String sonarProjectName = "${options['PROJECT_NAME']} ${sonarBranch}".trim()
                                    // Extrait la version au format attendu par SonarQube (<major.<minor>) √† partir de options['PYTHON_VERSION']
                                    String sonarPythonVersion = options['PYTHON_VERSION'].replaceAll(/(\d+\.\d+).*/, '$1')
                                    sh """\
                                        eul sonar-scanner \
                                        -Dsonar.projectKey=${options['PROJECT_SONAR_KEY_BRANCH']} \
                                        -Dsonar.projectName=\"${sonarProjectName}\" \
                                        -Dsonar.projectVersion=${env.VERSION} \
                                        -Dsonar.python.version=\"${sonarPythonVersion}\" \
                                        -Dsonar.links.ci=${JOB_URL} \
                                        -Dsonar.links.homepage=${GIT_URL} \
                                    """
                                }
                                println '‚úîÔ∏èÔ∏è Analyse qualit√© effectu√©e'
                            }
                        }
                    }
                }
                stage('Local CVE scan') {
                    container('python') {
                        println 'üî∞ Scan de s√©curit√© local sur les artefacts produits'
                        gitlabCommitStatus('local cve scan') {
                            // Scan CVE d√©clench√© avant la publication des artefacts pour ne pas publier d'artefact avec des vulnerabilit√©s
                            if (sh(script: 'eul artefacts cve-scan --local --critical --pip', returnStatus: true)) {
                                // La pr√©sence de cve dans les artefacts est bloquante
                                unstable "‚ö†Ô∏èÔ∏è Le scan de CVE a identifi√© des vuln√©rabilit√©s critiques dans l'artefact ou ses d√©pendances"
                            }
                        }
                        println '‚úîÔ∏èÔ∏è Scan CVE local effectu√©'
                    }
                }
                stage('Publish') {
                    when(publishEnabled) {
                        container('python') {
                            println "üî∞ Publication des artefacts du projet dans Artifactory depuis la branche ${BRANCH_NAME}"
                            gitlabCommitStatus('publication') {
                                // Packaging. S'il n'y a pas de module .whl √† produire, remplacer par : sh "eul python setup.py sdist --dist-dir ${env.VERSION}"
                                sh "eul python setup.py sdist --dist-dir ${env.VERSION} bdist_wheel --dist-dir ${env.VERSION}"
                                // Publication Python sur Artifactory
                                sh "eul artefacts upload -T pypi ${env.VERSION}/ ${options['PROJECT_NAME']}/"
                            }
                            // Publication des infos de build dans artifactory
                            sh 'eul artefacts build-publish'
                            // Publication Jenkins du lien sur le build Artifactory
                            publishArtifactoryBuildLink()
                            println '‚úîÔ∏è Publication des artefacts effectu√©e'
                        }
                    }
                }
                stage('CVE scan') {
                    when(publishEnabled) {
                        container('python') {
                            println 'üî∞ Scan CVE distant sur les artefacts produits sur Artifactory'
                            // Pour des raisons de performances, l'√©xecution du scan de build est asynchrone. C'est √† dire, le r√©sultat final du scan n'est pas attendu par le pipeline.
                            // Le lien artifactory vers le scan de build est publi√© directement dans le job et accessible.
                            // Pour forcer le pipeline √† attendre le r√©sultat du scan de build, il faut rajouter le flag `--wait-for-result` √† la commande de scan cve comme suit:
                            // <eul artefacts cve-scan --wait-for-result>
                            // cf: https://docs.apps.eul.sncf.fr/share/securise-scan-dependances
                            if (sh(script: 'eul artefacts cve-scan', returnStatus: true)) {
                                // Si le pipeline arrive √† ce stage cela veut dire qu'il a pass√© le scan local et ne pr√©sente pas de CVE critiques mais hautes.
                                // Pour mettre la pipeline en erreur, remplacer unstable "‚ö†Ô∏è..." par error "‚ùå..." dans la ligne suivante
                                unstable "‚ö†Ô∏èÔ∏è Le scan de CVE a identifi√© des vuln√©rabilit√©s hautes dans l'artefact ou ses d√©pendances"
                            }
                            println '‚úîÔ∏è Scan CVE distant effectu√©'
                        }
                    }
                }
                stage('Docker build') {
                    when(dockerEnabled) {
                        container('buildkit') {
                            println 'üî∞ build Docker avec Buildkit'
                            String dockerVerboseOption = options['IMAGE_BUILD_VERBOSE'] ? '--debug' : ''
                            env.IMAGE_NAME = options['PROJECT_NAME']
                            env.IMAGE_VERSION = env.VERSION

                            result = sh(script: """
                                eul image $dockerVerboseOption build docker --tag=$IMAGE_NAME:$IMAGE_VERSION \
                                --build-arg 'VERSION=$IMAGE_VERSION' --build-arg 'IMAGE_NAME=$IMAGE_NAME'  \
                                --build-arg EUL_REPO_USER='${EUL_REPO_USER}' --build-arg EUL_REPO_PASSWORD='${EUL_REPO_PASSWORD}'  \
                                --build-arg EUL_ARESIS='${EUL_ARESIS}' --build-arg PIP_PACKAGE_NAME='${PIP_PACKAGE_NAME}'
                                """, returnStatus: true)
                                
                            if (result != 0) {
                                error '‚ùå Le build Docker avec BuildKit a √©chou√©'
                            }
                            println '‚úîÔ∏è build Docker effectu√©'
                        }
                    }
                }
                // Voir https://jenkins.io/doc/pipeline/steps/gitlab-plugin/ pour plus de pr√©cisions
                updateGitlabCommitStatus name: 'build', state: 'success'
                println 'üëç Build du job de snapshot termin√© avec succ√®s'
                currentBuild.result = 'SUCCESS'
            } catch (all) {
                currentBuild.result = 'FAILURE'
                // Envoi d'un mail en cas d'√©chec
                // Voir https://jenkins.io/doc/pipeline/steps/email-ext/ pour plus de pr√©cisions
                emailext(
                    body: '$DEFAULT_CONTENT',
                    subject: '$DEFAULT_SUBJECT',
                    // Envoi du mail aux d√©veloppeurs responsables d'une modification du code
                    recipientProviders: [[$class: 'DevelopersRecipientProvider'], [$class: 'RequesterRecipientProvider']],
                    // Pour √©galement envoyer le mail √† une liste d'adresses (s√©par√©es par des ,) :
                    //to: "adressmail1, adressmail2"
                )
                throw all
            }
            finally {
                // Collecte et remont√©e dans Jenkins des probl√®mes rencontr√©s pendant le build
                addNgIssuesReportToJob('tools': ['cveScan', 'python', 'taskScanner'])
                // Pour le suivi et les indicateurs eUL
                eulNotify()
            }
        }
    }
}
